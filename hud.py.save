import tkinter as tk
from tkinter import messagebox, scrolledtext
from PIL import Image, ImageTk
import os, subprocess, random, math, sys, fcntl
from datetime import datetime

# --- SINGLE INSTANCE SHIELD ---
try:
    lock_file = open('/tmp/sumner_hud.lock', 'w')
    fcntl.lockf(lock_file, fcntl.LOCK_EX | fcntl.LOCK_NB)
except:
    sys.exit(0)

class SumnerHUD:
    def __init__(self, root):
        self.root = root
        self.sw = self.root.winfo_screenwidth()
        self.sh = self.root.winfo_screenheight()
        self.root.attributes('-fullscreen', True, "-topmost", True)
        self.root.config(bg='black')

        # --- PATHS ---
        self.path_allsky = "/var/www/html/allsky/images/latest.jpg"
        self.path_radar = "/home/pi/allsky_guard/radar.png"
        self.path_clock = "/home/pi/allsky_guard/clock_sumner.png"
        self.path_sensors = "/home/pi/allsky_guard/sensors.txt"
        self.path_hours = "/home/pi/allsky_guard/hours.txt"
        self.path_notes = "/home/pi/allsky_guard/dossier.txt"
        self.path_mirror_cfg = "/home/pi/allsky_guard/mirror_config.txt"
        
        self.app_manager = "/usr/share/applications/indigo-server-manager.desktop"
        self.app_imager = "/usr/share/applications/ain-imager.desktop"

        self.canvas = tk.Canvas(root, width=self.sw, height=self.sh, bg='black', highlightthickness=0)
        self.canvas.pack()
        
        self.draw_stars()
        self.create_ui_elements()
        self.check_cleaning_reminder()
        self.update_loop()

    def launch_seestar(self):
        w, h, x, y = "450", "900", "100", "100"
        if os.path.exists(self.path_mirror_cfg):
            try:
                with open(self.path_mirror_cfg, "r") as f:
                    coords = f.read().strip().split(',')
                    if len(coords) == 4: w, h, x, y = coords
            except: pass

        cmd = ["/snap/bin/scrcpy", "--always-on-top", "--window-title", "Seestar Live",
               "--max-size", "1920", "--video-bit-rate", "4M", "--max-fps", "30",
               "--window-x", x, "--window-y", y, "--window-width", w, "--window-height", h]
        subprocess.Popen(cmd)

    def check_cleaning_reminder(self):
        if os.path.exists(self.path_hours):
            try:
                with open(self.path_hours, "r") as f:
                    hrs = float(f.read().strip())
                    if hrs >= 1000.0:
                        messagebox.showwarning("MAINTENANCE", f"Alert: {hrs:.1f} Hours.\nClean dome/sensors.")
            except: pass

    def draw_stars(self):
        for _ in range(60):
            x, y = random.randint(0, self.sw), random.randint(0, self.sh)
            self.canvas.create_oval(x, y, x+1, y+1, fill='white', outline='white')

    def create_ui_elements(self):
        # 1. TOP BAR CONTROLS (Centered via percentage)
        self.canvas.create_text(self.sw//2, 25, text="--- OBSERVATORY CONTROLS ---", fill="#FFCC00", font=("Arial", 12, "bold"))
        
        btn_y = 55
        tk.Button(self.root, text="üöÄ INDIGO", bg="#003300", fg="white", font=("Arial", 9, "bold"),
                  command=lambda: subprocess.Popen(["gio", "launch", self.app_manager])).place(x=self.sw*0.25, y=btn_y, anchor="n")
        
        tk.Button(self.root, text="üî≠ IMAGER", bg="#001133", fg="white", font=("Arial", 9, "bold"),
                  command=lambda: subprocess.Popen(["gio", "launch", self.app_imager])).place(x=self.sw*0.35, y=btn_y, anchor="n")

        tk.Button(self.root, text="üì± SEESTAR", bg="#4B0082", fg="white", font=("Arial", 9, "bold"),
                  command=self.launch_seestar).place(x=self.sw*0.45, y=btn_y, anchor="n")

        tk.Button(self.root, text="üìÇ DOSSIER", command=self.open_dossier, bg="#222", fg="white", font=("Arial", 9, "bold")).place(x=self.sw*0.55, y=btn_y, anchor="n")
        
        tk.Button(self.root, text="EXIT HUD", command=self.root.destroy, bg="#500", fg="white", font=("Arial", 9, "bold")).place(x=self.sw*0.65, y=btn_y, anchor="n")

        # 2. SENSOR BOX (Relative width and height)
        box_w = int(self.sw * 0.28)
        box_h = int(self.sh * 0.85)
        rx = self.sw - box_w - 20
        ry = 40
        self.canvas.create_rectangle(rx, ry, rx + box_w, ry + box_h, fill='#050505', outline='#00FFCC', width=2)
        
        y_off = ry + 40
        spacing = box_h // 11
        self.val_sky   = self.add_sensor_line("üå°Ô∏è", "SKY TEMP:", rx + 15, y_off, "#AAB7B8")
        self.val_cloud = self.add_sensor_line("‚òÅÔ∏è", "SKY COND:", rx + 15, y_off + spacing, "#5DADE2")
        self.val_amb   = self.add_sensor_line("üå°Ô∏è", "AMB TEMP:", rx + 15, y_off + spacing*2, "#EC7063")
        self.val_hum   = self.add_sensor_line("üíß", "HUMIDITY:", rx + 15, y_off + spacing*3, "#5499C7")
        self.val_dew   = self.add_sensor_line("‚ú®", "DEW POINT:", rx + 15, y_off + spacing*4, "#A569BD")
        self.val_pres  = self.add_sensor_line("‚è≤Ô∏è", "PRESSURE:", rx + 15, y_off + spacing*5, "#58D68D")
        self.val_wind  = self.add_sensor_line("üí®", "WIND SPD:", rx + 15, y_off + spacing*6, "#F4D03F")
        self.val_rain  = self.add_sensor_line("‚òî", "RAIN DET:", rx + 15, y_off + spacing*7, "#AF7AC5")
        self.val_dome  = self.add_sensor_line("üè†", "ROOF STAT:", rx + 15, y_off + spacing*8, "#EB984E")
        self.val_hrs   = self.add_sensor_line("‚åõ", "OP HOURS:", rx + 15, y_off + spacing*9.5, "#FFCC00")
        self.sync_light = self.canvas.create_oval(rx + 15, y_off + spacing*9.5 - 8, rx + 31, y_off + spacing*9.5 + 8, fill="gray", outline="white")

        # 3. IMAGES (Grid layout to prevent overlap)
        self.all_img_id = self.canvas.create_image(self.sw*0.32, self.sh*0.35, anchor='center', tags="zoom")
        self.rad_img_id = self.canvas.create_image(self.sw*0.68, self.sh*0.35, anchor='center', tags="zoom")
        self.clk_img_id = self.canvas.create_image(self.sw*0.48, self.sh*0.80, anchor='center', tags="zoom")

        self.canvas.tag_bind(self.all_img_id, "<Button-1>", lambda e: self.popout(self.path_allsky))
        self.canvas.tag_bind(self.rad_img_id, "<Button-1>", lambda e: self.popout(self.path_radar))
        self.canvas.tag_bind(self.clk_img_id, "<Button-1>", lambda e: self.popout(self.path_clock))

    def add_sensor_line(self, icon, label, x, y, color):
        f_size = 14 if self.sw > 1000 else 10
        self.canvas.create_text(x, y, text=icon, anchor='w', fill=color, font=("Arial", f_size + 4))
        self.canvas.create_text(x + 35, y, text=label, anchor='w', fill="white", font=("Arial", f_size, "bold"))
        return self.canvas.create_text(x + (self.sw*0.25), y, text="--", anchor='e', fill="cyan", font=("Courier", f_size + 4, "bold"))

    def popout(self, path):
        if not os.path.exists(path): return
        pop = tk.Toplevel(self.root)
        pop.attributes("-fullscreen", True, "-topmost", True)
        pop.config(bg='black')
        img = Image.open(path)
        img.thumbnail((self.sw, self.sh), Image.Resampling.LANCZOS)
        self.p_img = ImageTk.PhotoImage(img)
        tk.Button(pop, image=self.p_img, bg='black', bd=0, activebackground='black', command=pop.destroy).pack(expand=True)

    def open_dossier(self):
        d_win = tk.Toplevel(self.root)
        d_win.geometry(f"{int(self.sw*0.8)}x{int(self.sh*0.8)}")
        d_win.config(bg="#050505")
        d_win.attributes("-topmost", True)
        tk.Label(d_win, text="SYSTEM DOSSIER", bg="#050505", fg="#FFCC00", font=("Arial", 18, "bold")).pack(pady=10)
        
        m_frame = tk.Frame(d_win, bg="#111")
        m_frame.pack(fill="x", padx=20)
        tk.Label(m_frame, text="Mirror Config (W,H,X,Y):", bg="#111", fg="white").pack(side="left")
        cfg_entry = tk.Entry(m_frame, bg="black", fg="cyan", insertbackground="white")
        cfg_entry.pack(side="left", padx=10)
        if os.path.exists(self.path_mirror_cfg):
            with open(self.path_mirror_cfg, "r") as f: cfg_entry.insert(0, f.read().strip())

        txt = scrolledtext.ScrolledText(d_win, bg="black", fg="#00FFCC", font=("Courier", 14), insertbackground="white")
        txt.pack(padx=20, pady=5, expand=True, fill='both')
        if os.path.exists(self.path_notes):
            with open(self.path_notes, "r") as f: txt.insert('1.0', f.read())
        
        btn_f = tk.Frame(d_win, bg="#050505")
        btn_f.pack(fill="x", side="bottom", pady=20)
        
        def save_all():
            with open(self.path_mirror_cfg, "w") as f: f.write(cfg_entry.get())
            with open(self.path_notes, 'w') as f: f.write(txt.get('1.0', 'end'))
            d_win.destroy()

        def reset_h():
            if messagebox.askyesno("RESET", "Reset maintenance timer?"):
                with open(self.path_hours, "w") as f: f.write("0.0")

        tk.Button(btn_f, text="‚ôª RESET TIMER", bg="#D4AC0D", font=("Arial", 11, "bold"), command=reset_h).pack(side="left", padx=50)
        tk.Button(btn_f, text="üíæ SAVE & EXIT", bg="#1E8449", fg="white", font=("Arial", 11, "bold"), command=save_all).pack(side="right", padx=50)

    def update_loop(self):
        # Image sizes now relative to screen width (roughly 30% of screen)
        thumb_w = int(self.sw * 0.32)
        thumb_h = int(self.sh * 0.45)
        
        self.img_all = self.load_scale(self.path_allsky, thumb_w, thumb_h)
        if self.img_all: self.canvas.itemconfig(self.all_img_id, image=self.img_all)
        self.img_rad = self.load_scale(self.path_radar, thumb_w, thumb_h)
        if self.img_rad: self.canvas.itemconfig(self.rad_img_id, image=self.img_rad)
        self.img_clk = self.load_scale(self.path_clock, int(self.sw*0.5), int(self.sh*0.35))
        if self.img_clk: self.canvas.itemconfig(self.clk_img_id, image=self.img_clk)

        # Hour Logging and Sensor Parsing remains the same...
        if os.path.exists(self.path_hours):
            try:
                mtime = os.path.getmtime(self.path_hours)
                diff = (datetime.now().timestamp() - mtime) / 60
                self.canvas.itemconfig(self.sync_light, fill="#00FF00" if diff < 20 else "#FF0000")
                with open(self.path_hours, "r") as f:
                    self.canvas.itemconfig(self.val_hrs, text=f"{f.read().strip()} HRS")
            except: pass

        if os.path.exists(self.path_sensors):
            try:
                sky_t, amb_t, hum_val = None, None, None
                with open(self.path_sensors, "r") as f:
                    for line in f:
                        u_line = line.upper().strip()
                        if ":" not in u_line: continue
                        val = line.split(":", 1)[-1].strip()
                        if "SKY TEMP" in u_line: 
                            self.canvas.itemconfig(self.val_sky, text=val)
                            try: sky_t = float(''.join(c for c in val if c in '0123456789.-'))
                            except: pass
                        elif "AMB TEMP" in u_line: 
                            self.canvas.itemconfig(self.val_amb, text=val)
                            try: amb_t = float(''.join(c for c in val if c in '0123456789.-'))
                            except: pass
                        elif "HUMIDITY" in u_line: 
                            self.canvas.itemconfig(self.val_hum, text=val)
                            try: hum_val = float(''.join(c for c in val if c in '0123456789.-'))
                            except: pass
                        elif "PRESSURE" in u_line: self.canvas.itemconfig(self.val_pres, text=val)
                        elif "WIND SPD" in u_line: self.canvas.itemconfig(self.val_wind, text=val)
                        elif "PRECIP" in u_line or "RAIN" in u_line: 
                            self.canvas.itemconfig(self.val_rain, text=val, fill="red" if "WET" in
